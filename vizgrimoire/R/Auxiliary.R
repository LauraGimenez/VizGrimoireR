## Copyright (C) 2012, 2013 Bitergia
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU General Public License for more details. 
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
##
## This file is a part of the vizGrimoire R package
##  (an R library for the MetricsGrimoire and vizGrimoire systems)
##
## Auxiliary.R
##
## Auxiliary code for the classes in the package
##
## Authors:
##   Jesus M. Gonzalez-Barahona <jgb@bitergia.com>
##   Daniel Izquierdo <dizquierdo@bitergia.com>
##   Alvaro del Castillo <acs@bitergia.com>
##
## Note: this file should be (alphabetically) the first one in the list
##  of files with R source code for the package. It seems that files are
##  run in alphabetic order, and this one includes facilities needed by
##  the rest. An alternative would be to use a "Collate" field in the
##  DESCRIPTION file.
##

## Get arguments from the command line
##
##  - dbschema: MySQL database schema to use, generated by CVSAnalY2
##  - user: MySQL user with permissions to access the schema
##  - passwd: password corresponding to user
##  - enddate: final date of the period to analyze. Format: YYYY-MM-DD
##      (in fact, first day after the period)
##  - startdate: starting date of the period to analyze. Format: YYYY-MM-DD
##
##
ConfFromCommandLine <- function () {
  ## Get command line args, and produce variables for the script
  args <- commandArgs(trailingOnly = TRUE)

  if (length(args) > 3) {
    enddate <- args[4]
  } else {
    enddate <- "2100-01-01"
  }
  enddatesplit <- strsplit(enddate,'-')
  endyear <- enddatesplit[[1]][1]
  endmonth <- enddatesplit[[1]][2]
  enddate <- paste (c("'", enddate, "'"), collapse='')
  
  if (length(args) > 4) {
    startdate <- args[5]
  } else {
    startdate <- "1900-01-01"
  }
  startdatesplit <- strsplit(startdate,'-')
  startyear <- startdatesplit[[1]][1]
  startmonth <- startdatesplit[[1]][2]
  startdate <- paste (c("'", startdate, "'"), collapse='')

  conf <- list (database = args[1],
                user = args[2],
                password = args[3],
                startdate = startdate,
                enddate = enddate)
  return (conf)
}

library(optparse)

ConfFromOptParse <- function (datasource="") {
	option_list <- list(			
			make_option(c("-d", "--database"), dest="database", 
					help="Database with MLS data"),
			make_option(c("-u", "--dbuser"), dest="dbuser", 
					help="Database user", default="root"),
			make_option(c("-p", "--dbpass"), dest="dbpassword", 
					help="Database user password", default=""),			
			make_option(c("-r", "--reports"), dest="reports", default="",
					help="Reports to be generated (repositories, companies)"),			
			make_option(c("-s", "--start"), dest="startdate", 
					help="Start date for the report", default="1900-01-01"),
			make_option(c("-e", "--end"), dest="enddate", 
					help="End date for the report", default="2100-01-01")
	)	
	if (datasource == 'its') {
		option_list = c(option_list, make_option(
			c("-t", "--type"), dest="backend", 
			help="Type of backend: bugzilla, allura, jira, github", 
			default="bugzilla"));	
	}
	parser <- OptionParser(usage = "%prog [options]", option_list = option_list)
	options <- parse_args(parser)	
	if (is.null(options$database)) {		
		print_help(parser)
		stop("Database param is required")
	}
	enddatesplit <- strsplit(options$enddate,'-')
	endyear <- enddatesplit[[1]][1]
	endmonth <- enddatesplit[[1]][2]
	options$enddate <- paste (c("'", options$enddate, "'"), collapse='')
	
	startdatesplit <- strsplit(options$startdate,'-')
	startyear <- startdatesplit[[1]][1]
	startmonth <- startdatesplit[[1]][2]
	options$startdate <- paste (c("'", options$startdate, "'"), collapse='')
		
	return (options)
}

## Get arguments from parameters to this function
##
##  - dbschema: MySQL database schema to use, generated by CVSAnalY2
##  - user: MySQL user with permissions to access the schema
##  - passwd: password corresponding to user
##  - enddate: final date of the period to analyze. Format: YYYY-MM-DD
##      (in fact, first day after the period)
##  - startdate: starting date of the period to analyze. Format: YYYY-MM-DD
##
##
ConfFromParameters <- function (dbschema, user = NULL, password = NULL,
                                host = "127.0.0.1", port = 3306,
                                group = NULL,
                                enddate = NULL, startdate = NULL) {
  if (is.null(enddate)) {
    enddate <- "2100-01-01"
  }
  enddate <- paste (c("'", enddate, "'"), collapse='')
  if (is.null(startdate)) {
    startdate <- "1900-01-01"
  }
  startdate <- paste (c("'", startdate, "'"), collapse='')

  conf <- list (database = dbschema,
                user = user,
                password = password,
                host = host,
                port = port,
                group = group,
                startdate = startdate,
                enddate = enddate)
  return (conf)
}

##
## Penalize scientific notation by 10 chars
##
options(scipen=10)

##
## Database-related classes & functions
##

library(RMySQL)
##
## Connect to the database and prepare...
##

SetDBChannel <- function (user=NULL, password=NULL, database,
                          host="127.0.0.1", port=3306,
                          group=NULL) {
  if (is.null(group)) {
    mychannel <<- dbConnect(MySQL(), user=user, password=password,
                            db=database, host=host, port=port)
  } else {
    mychannel <<- dbConnect(MySQL(), group=group,
                            db=database)
  }    
  dbGetQuery(mychannel, "SET NAMES 'utf8'")
}

##
## Close connection to the database
##

CloseDBChannel <- function () {
  dbDisconnect(mychannel)
}

##
## Find out kind of repository (bugzilla, launchpad, etc.) and
##  store it in common configuration list
##
FindoutRepoKind <- function () {
  q <- new ("Query", sql = "SELECT name FROM supported_trackers")
  kind <- run(q)$name[1]
  return (kind)
}

# Note use display.brewer.pal(...) to check colors
# example: display.brewer.pal(9, "Greens")
library(RColorBrewer)

blues = brewer.pal(5,'Blues')
reds = brewer.pal(5,'Reds')
greens = brewer.pal(5,'Greens')

#
# List of colors for plots
#
colors <- c("black", "green", "red", "blue", "orange", "brown")


# Complete a weekly dataframe with zero for missing weeks
#
# Gets as input a dataframe with weekly data. It hast to
# include a "yearweek" column, which is an integer year*52+week
# Produces a dataframe with zero rows for missing weeks
#
completeZeroWeekly <- function (data) {

  firstweek = as.integer(data$yearweek[1])
  lastweek = as.integer(data$yearweek[nrow(data)])
  weeks = data.frame('yearweek'=c(firstweek:lastweek))
  completedata <- merge (data, weeks, all=TRUE)
  completedata[is.na(completedata)] <- 0
  return (completedata)
}

# Merge two dataframes with weekly data, filling holes with 0
#
# Both dataframes should have a "yearweek" column,
# which is an integer year*52+week
#
mergeWeekly <- function (d1, d2) {

  d = completeZeroWeekly (merge (d1, d2, all=TRUE))

  return (d)
}

# Complete a monthly dataframe with zero for missing months
#
# Gets as input a dataframe with montly data. It hast to
# include a "id" column, which is an integer year*12+month
# Produces a dataframe with zero rows for missing months
#
completeZeroMonthly <- function (data) {

  firstmonth = as.integer(data$id[1])
  lastmonth = as.integer(data$id[nrow(data)])
  months = data.frame('id'=c(firstmonth:lastmonth))
  completedata <- merge (data, months, all=TRUE)
  completedata[is.na(completedata)] <- 0
  return (completedata)
}

# Merge two dataframes with monthly data, filling holes with 0
#
# Both dataframes should have a "id" column,
# which is an integer year*12+week
#
mergeMonthly <- function (d1, d2) {

  d = completeZeroMonthly (merge (d1, d2, all=TRUE))

  return (d)
}

##
## toTextDate: convert two vectors with integers for year, month into
##  a vector with text
##
## Example: 2012, 2 -> Feb 2012
##
toTextDate <- function (year, month) {
  abb.months <- c('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
  text <- paste (abb.months[month], as.character(year))
  return (text)
}

##
## GetYear
##
## Get the year of a datetime object
##
## Year as four digits (eg: 2012)
##
GetYear <- function (time) {
  return (1900 + as.POSIXlt(time)$year)
}

##
## GetMonth
##
## Get the month of a datetime object
##
## Month as an integer 0:11 (eg: Jan is 0)
##
GetMonth <- function (time) {
  return (as.POSIXlt(time)$mon)
}


#
# Plot several columns of a timeserie
#
#  data: data frame to plot
#  columns: names of the columns in data frame to plot
#  labels: strings to show as labels
#

## plotTimeSerieWeekN <- function (data, columns, filename, labels=columns) {

##   pdffilename <- paste (c(filename, ".pdf"), collapse='')
##   pdffilenamediff <- paste (c(filename, "-diff.pdf"), collapse='')
##   pdffilenamecum <- paste (c(filename, "-cumsum.pdf"), collapse='')
  
##   # Build label for Y axis
##   label <- ""
##   for (col in 1:length(columns)) {
##     if (col != 1) {
##       label <- paste (c(label, " / "), collapse='')
##     }
##     label = paste (c(label, labels[col], " (", colors[col] ,")"),
##       collapse='')
##   }
  
##   # Regular plot
##   pdf(file=pdffilename, height=3.5, width=5)
##   timeserie <- ts (data[columns[1]],
##                    start=c(data$year[1],data$week[1]), frequency=52)
##   ts.plot (timeserie, col=colors[1], ylab=label)
##   if (length (columns) > 1) {
##     for (col in 2:length(columns)) {
##       timeserie <- ts (data[columns[col]],
##                        start=c(data$year[1],data$week[1]), frequency=52)
##       lines (timeserie, col=colors[col])
##     }
##   }
##   dev.off()

# Cummulative plot
#    pdf(file=pdffilenamecum, height=3.5, width=5)
#    timeserie <- ts (cumsum(data[columns[1]]),
#       start=c(data$year[1],data$month[1]), frequency=12)
#    ts.plot (timeserie, col=colors[1], ylab=label)
#    if (length (columns) > 1) {
#       for (col in 2:length(columns)) {
#          timeserie <- ts (cumsum(data[columns[col]]),
#             start=c(data$year[1],data$month[1]), frequency=12)
#          lines (timeserie, col=colors[col])
#       }
#    }
#    dev.off()
## }

#
# Plot several columns of a timeserie
#
#  data: data frame to plot
#  columns: names of the columns in data frame to plot
#  labels: strings to show as labels
#

## plotTimeSerieMonthN <- function (data, columns, filename, labels=columns) {

##   pdffilename <- paste (c(filename, ".pdf"), collapse='')
##   pdffilenamediff <- paste (c(filename, "-diff.pdf"), collapse='')
##   pdffilenamecum <- paste (c(filename, "-cumsum.pdf"), collapse='')
  
##   # Build label for Y axis
##   label <- ""
##   for (col in 1:length(columns)) {
##     if (col != 1) {
##       label <- paste (c(label, " / "), collapse='')
##     }
##     label = paste (c(label, labels[col], " (", colors[col] ,")"),
##       collapse='')
##   }
  
##   # Regular plot
##   pdf(file=pdffilename, height=3.5, width=5)
##   timeserie <- ts (data[columns[1]],
##                    start=c(data$year[1],data$month[1]), frequency=12)
##   ts.plot (timeserie, col=colors[1], ylab=label)
##   if (length (columns) > 1) {
##     for (col in 2:length(columns)) {
##       timeserie <- ts (data[columns[col]],
##                        start=c(data$year[1],data$month[1]), frequency=12)
##       lines (timeserie, col=colors[col])
##     }
##   }
##   dev.off()

# Cummulative plot
#    pdf(file=pdffilenamecum, height=3.5, width=5)
#    timeserie <- ts (cumsum(data[columns[1]]),
#       start=c(data$year[1],data$month[1]), frequency=12)
#    ts.plot (timeserie, col=colors[1], ylab=label)
#    if (length (columns) > 1) {
#       for (col in 2:length(columns)) {
#          timeserie <- ts (cumsum(data[columns[col]]),
#             start=c(data$year[1],data$month[1]), frequency=12)
#          lines (timeserie, col=colors[col])
#       }
#    }
#    dev.off()
## }

## plotTimeSerieYearN <- function (data, columns, filename, labels=columns) {

##   pdffilename <- paste (c(filename, ".pdf"), collapse='')
##   pdffilenamelog <- paste (c(filename, "-log.pdf"), collapse='')
##   pdffilenamediff <- paste (c(filename, "-diff.pdf"), collapse='')
##   pdffilenamecum <- paste (c(filename, "-cumsum.pdf"), collapse='')

##   # Build label for Y axis
##   label <- ""
##   for (col in 1:length(columns)) {
##     if (col != 1) {
##       label <- paste (c(label, " / "), collapse='')
##     }
##     label = paste (c(label, labels[col], " (", colors[col] ,")"),
##       collapse='')
##   }
  
##   timeserie <- ts (data[columns], start=data$year[1])
##   ## Regular plot
##   pdf(file=pdffilename, height=3.5, width=5)
##   ts.plot (timeserie, gpars=list(col=colors, ylab=label))
##   dev.off()
##   ## Log10 plot
##   pdf(file=pdffilenamelog, height=3.5, width=5)
##   ts.plot (log10(timeserie), gpars=list(col=colors, ylab=label))
##   dev.off()
  
  
# Cummulative plot
#    pdf(file=pdffilenamecum, height=3.5, width=5)
#    timeserie <- ts (cumsum(data[columns[1]]),
#       start=c(data$year[1],data$month[1]), frequency=12)
#    ts.plot (timeserie, col=colors[1], ylab=label)
#    if (length (columns) > 1) {
#       for (col in 2:length(columns)) {
#          timeserie <- ts (cumsum(data[columns[col]]),
#             start=c(data$year[1],data$month[1]), frequency=12)
#          lines (timeserie, col=colors[col])
#       }
#    }
#    dev.off()
## }


#
# Plot histogram and density of probability for data frame (single column)
#
plotHistogramTime <- function (data, filename, label, title='') {

  pdffilename <- paste (c(filename, ".pdf"), collapse='')
  pdf(pdffilename, height=5, width=5)
#  hist(data, prob= T, breaks='FD', col=blues[3], xlab = label, main = title)
  hist(data, freq=TRUE, breaks=15, col="orange", xlab = label, main = title)
#  lines(density(data), col=reds[3], lwd = 2)
  dev.off()
}
#library(vioplot)

#
# Plot boxplot for data frame
#
plotBoxPlot <- function (data, filename, label = '', title = '') {
  
  pdffilename <- paste (c(filename, ".pdf"), collapse='')
  pdf(pdffilename, height=10, width=2)
  boxplot(data, col = greens[2], main = title, ylab = "days", xlab = label)
  # Mark top 3 outliers
  #top3 = rev(sort(data))[1:3]
  #print(top3)
  #text(rep(1,3), y = top3, label = paste(top3, 'days'), pos = 4)
  dev.off()
}

#
# Plot distribution of times
#
# Plots several charts:
#  - Histogram and density of probability for all tickets
#  - Histogram and density of probability for quickly closed tickets
#  - Histogram and density of probability for slowly closed tickets
# Threshold is for splitting in quick/slow (in days)
#
## plotTimeDist <- function (data, filename, unit = 'days', threshold = 30,
##                           variable = 'Time') {

##   label <- paste (c(variable, ' (', unit, ')'), collapse='')
##   # All tickets
##   plotHistogramTime (data, filename, label)
##   plotBoxPlot (data, paste (c (filename, '-boxplot'), collapse=''))
##   # Quickly closed tickets
##   quickly <- data[data <= threshold]
##   if (length(quickly) > 0) {
##     plotHistogramTime (quickly, paste (c (filename, '-quick'), collapse=''),
##                        label)
##     plotBoxPlot (quickly, paste (c (filename, '-quick-boxplot'), collapse=''))
##   }
##   # Slowly closed tickets
##   slowly <- data[data > threshold]
##   if (length(slowly) > 0) {
##     plotHistogramTime (slowly, paste (c (filename, '-slow'), collapse=''),
##                        label)
##     plotBoxPlot (slowly, paste (c (filename, '-slow-boxplot'), collapse=''))
##   }
## #  pdf(paste (c (filename, '-vioplot.pdf'), collapse=''), height=10, width=4)
## #  vioplot(data, quickly, slowly, col='gold', varwidth=TRUE)
## #  dev.off()
## }

## #
## # Plot time distributions and boxplots for time to fix in all years
## #
## plotTimeDistYear <- function (data, filename) {
##   for (year in data$year_open[1] : data$year_open[nrow(data)]) {
##     filename = paste(c(filename, '-',year), collapse='')
##     yearData <- data[data$year_open == year,]
##     plotTimeDist (yearData$ttofixm, filename, 'minutes',
##                   variable = 'Time to fix, first close')
##   }
## }

##
## Produce charts in several formats
##
produce.charts <- function (chart, filename, height = 4, width = 4) {
  if (! is.null(filename)) {
    pdffilename <- paste (c(filename, ".pdf"), collapse='')
    pdf(file=pdffilename, height=height, width=width)
    print (chart)
    dev.off()
    jpegfilename <- paste (c(filename, ".jpeg"), collapse='')
    jpeg(file=jpegfilename, height=height*75, width=width*75, quality=90)
    print (chart)
    dev.off()
  } else {
    print (chart)
  }
}

##
## binplot.3d
##
## Plot a bin in 3D, using rgl
## Code extracted from the rgl 3D histogram demo
##
binplot.3d <- function(x,y,z,alpha=1,topcol="red",sidecol="#aaaaaa")
{
  save <- par3d(skipRedraw=TRUE)
  on.exit(par3d(save))
  
  x1<-c(rep(c(x[1],x[2],x[2],x[1]),3),rep(x[1],4),rep(x[2],4))
  z1<-c(rep(0,4),rep(c(0,0,z,z),4))
  y1<-c(y[1],y[1],y[2],y[2],rep(y[1],4),rep(y[2],4),rep(c(y[1],y[2],y[2],y[1]),2))
  x2<-c(rep(c(x[1],x[1],x[2],x[2]),2),rep(c(x[1],x[2],rep(x[1],3),rep(x[2],3)),2))
  z2<-c(rep(c(0,z),4),rep(0,8),rep(z,8) )
  y2<-c(rep(y[1],4),rep(y[2],4),rep(c(rep(y[1],3),rep(y[2],3),y[1],y[2]),2) )
  rgl.quads(x1,z1,y1,col=rep(sidecol,each=4),alpha=alpha)
  rgl.quads(c(x[1],x[2],x[2],x[1]),rep(z,4),c(y[1],y[1],y[2],y[2]),
            col=rep(topcol,each=4),alpha=1) 
  rgl.lines(x2,z2,y2,col="#000000")
}

##
## hist3d
##
## Plot a 3D histogram
## Code based in the rgl 3D histogram demo
##
hist3d<-function(x,y=NULL,x.nclass="auto",y.nclass="auto",alpha=1,
                 cols=c("green","red","blue"),y.scale=200, z.scale=5)
{
  if (!is.numeric(y)) {
    values.y <- sort(unique(y))
    subst <- 0
    for (value in values.y) {
      subst <- subst + 1
      y[y==value] <- subst * y.scale
    }
    if (y.nclass == "auto") {
      y.nclass <- length(values.y)
    }
  }
  xy <- xy.coords(x,y)
  x <- xy$x
  if (x.nclass == "auto") {
    x.nclass<-ceiling(sqrt(nclass.Sturges(x)))
    }
  y <- xy$y
  breaks.x <- seq(min(x)-1,max(x)+1, length=(x.nclass+1))
  breaks.y <- seq(min(y)-1,max(y)+1,length=(y.nclass+1))
  z<-matrix(0,(x.nclass),(y.nclass))
  save <- par3d(skipRedraw=TRUE)
  on.exit(par3d(save))
  for (i in 1:x.nclass) 
  {
    for (j in 1:y.nclass) 
    {
      z[i, j] <- sum(x < breaks.x[i+1] & y < breaks.y[j+1] & 
        x >= breaks.x[i] & y >= breaks.y[j])
      binplot.3d(c(breaks.x[i],breaks.x[i+1]),c(breaks.y[j],breaks.y[j+1]),
                 z.scale*z[i,j],alpha=alpha,topcol=cols[j],sidecol=cols[j])
    }
  }
}


##
## Generic JSON function for using it in hierarchies of objects that need it
##
setGeneric (
 name= "JSON",
 def=function(.Object,...){standardGeneric("JSON")}
 )

##
## Generic Plot function for using it in hierarchies of objects that need it
##
setGeneric (
  name= "Plot",
  def=function(.Object,...){standardGeneric("Plot")}
  )

##
## Generic PlotDist function for using it in hierarchies of objects that need it
##
setGeneric (
 name= "PlotDist",
 def=function(object,...){standardGeneric("PlotDist")}
 )

##
## Code for producing JSON files suitable for vizGrimoire.JS
##
## All of this should still be re-coded as classes, but is here
## now for convenience, as a first step to support vizGrimoire.JS
##
library(rjson)

##
## Create a JSON file with some R object
##
createJSON <- function (data, filename) {
   sink(filename)
   cat(toJSON(data))
   sink()
}

evol_commits <- function(granularity){
  #Commits evolution

  q<- paste("select m.id as id,
                  m.year as year,
                  m.month as month,
                  DATE_FORMAT(m.date, '%b %Y') as date,
                  IFNULL(pm.commits, 0) as commits
           from   months m
           left join(
                  select year(s.date) as year, 
                         month(s.date) as month, 
                         count(distinct(s.id)) as commits
                  from   scmlog s 
                  group by year(s.date),
                         month(s.date)
                  order by year(s.date),
                         month(s.date) ) as pm
           on (
                  m.year = pm.year and
                  m.month = pm.month);")

  query <- new ("Query", sql = q)
  data_commits <- run(query)
  return (data_commits)
}


evol_committers <- function(granularity){
  #Committers evolution
  q <- paste ("select m.id as id,
                  m.year as year,
                  m.month as month,
                  DATE_FORMAT(m.date, '%b %Y') as date,
                  IFNULL(pm.committers, 0) as committers
           from   months m
           left join(
                  select year(s.date) as year, 
                         month(s.date) as month, 
                         count(distinct(s.committer_id)) as committers
                  from   scmlog s 
                  group by year(s.date),
                         month(s.date)
                  order by year(s.date),
                         month(s.date) ) as pm
           on (
                  m.year = pm.year and
                  m.month = pm.month);")

  query <- new ("Query", sql = q)
  data_committers <- run(query)
  return (data_committers)
}

evol_authors <- function(granularity){
	# Authors evolution
	q <- paste ("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.authors, 0) as authors
					from   months m
					left join(
					select year(s.date) as year, 
					month(s.date) as month, 
					count(distinct(s.author_id)) as authors
					from   scmlog s 
					group by year(s.date),
					month(s.date)
					order by year(s.date),
					month(s.date) ) as pm
					on (
					m.year = pm.year and
					m.month = pm.month);")
	
        query <- new ("Query", sql = q)
        data_authors <- run(query)
	return (data_authors)
}



evol_files <- function(granularity){

  #Files per month
  q <- paste("select m.id as id,
                  m.year as year,
                  m.month as month,
                  DATE_FORMAT(m.date, '%b %Y') as date,
                  IFNULL(pm.files, 0) as files
           from   months m
           left join(
                  select year(s.date) as year, 
                         month(s.date) as month, 
                         count(distinct(a.file_id)) as files
                  from   scmlog s, 
                         actions a
                  where  a.commit_id = s.id
                  group by year(s.date),
                         month(s.date)
                  order by year(s.date),
                         month(s.date) ) as pm
           on (
                  m.year = pm.year and
                  m.month = pm.month);")


  query <- new ("Query", sql = q)
  data_files <- run(query)
  return (data_files)
}


evol_branches <- function(granularity){

  #Branches per month
  q <- paste("select m.id as id,
                  m.year as year,
                  m.month as month,
                  DATE_FORMAT(m.date, '%b %Y') as date,
                  IFNULL(pm.branches, 0) as branches
           from   months m
           left join(
                  select year(s.date) as year, 
                         month(s.date) as month, 
                         count(distinct(a.branch_id)) as branches
                  from   scmlog s, 
                         actions a
                  where  a.commit_id = s.id
                  group by year(s.date),
                         month(s.date)
                  order by year(s.date),
                         month(s.date) ) as pm
           on (     
                  m.year = pm.year and
                  m.month = pm.month);")

  query <- new ("Query", sql = q)
  data_branches <- run(query)
  return (data_branches)
}


evol_repositories <- function(granularity) {

  # Repositories per month
  q <- paste("select m.id as id,
                  m.year as year,
                  m.month as month,
                  DATE_FORMAT(m.date, '%b %Y') as date,
                  IFNULL(pm.repositories, 0) as repositories
           from   months m
           left join(
                  select year(s.date) as year,
                         month(s.date) as month,
                         count(distinct(s.repository_id)) as repositories
                  from   scmlog s
                  group by year(s.date),
                         month(s.date)
                  order by year(s.date),
                         month(s.date) ) as pm
           on (
                  m.year = pm.year and
                  m.month = pm.month);")
  query <- new ("Query", sql = q)
  data_repositories <- run(query)
  return (data_repositories)
}

evol_companies <- function(){	
	q <- paste("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.companies, 0) as num_companies
				from   months m
				left join(
					select year(s.date) as year,
						month(s.date) as month,
						count(distinct(pc.company_id)) as companies
					from   scmlog s,
						people_companies pc
					where  s.author_id = pc.people_id and
						s.date>=pc.init and 
						s.date<=pc.end
					group by year(s.date), month(s.date)
					order by year(s.date), month(s.date)) 
				as pm
				on (  
					m.year = pm.year and
					m.month = pm.month)
				order by m.id;")	
	companies<- query(q)
	return(companies)
}

evol_info_data <- function() {
	# Get some general stats from the database
	##
	q <- paste("SELECT count(id) as commits, 
					count(distinct(committer_id)) as committers, 
					count(distinct(author_id)) as authors, 
					DATE_FORMAT (min(date), '%Y-%m-%d') as first_date, 
					DATE_FORMAT (max(date), '%Y-%m-%d') as last_date 
					FROM scmlog;")
	query <- new("Query", sql = q)
	data1 <- run(query)
	
	q <- paste("SELECT count(distinct(name)) as branches from branches")
	query <- new("Query", sql = q)
	data2 <- run(query)	
	
	q <- paste("SELECT count(distinct(file_name)) as files from files")
	query <- new("Query", sql = q)
	data3 <- run(query)	
	
	q <- paste("SELECT count(distinct(uri)) as repositories from repositories")
	query <- new("Query", sql = q)
	data4 <- run(query)	
	
	q <- paste("SELECT count(*) as actions from actions")
	query <- new("Query", sql = q)
	data5 <- run(query)	
	
	q <- paste("select uri as url,type from repositories limit 1")
	query <- new("Query", sql = q)
	data6 <- run(query)	
	
	q <- paste("select count(distinct(s.id))/timestampdiff(month,min(s.date),max(s.date)) 
					as avg_commits_month from scmlog s")
	query <- new("Query", sql = q)
	data7 <- run(query)	
	
	q <- paste("select count(distinct(a.file_id))/timestampdiff(month,min(s.date),max(s.date)) 
					as avg_files_month from scmlog s, actions a where a.commit_id=s.id")
	query <- new("Query", sql = q)
	data8 <- run(query)	
	
	q <- paste("select count(distinct(s.id))/count(distinct(p.id)) 
					as avg_commits_author from scmlog s, people p where p.id=s.author_id")
	query <- new("Query", sql = q)
	data9 <- run(query)	
	
	q <- paste("select count(distinct(s.author_id))/timestampdiff(month,min(s.date),max(s.date)) 
					as avg_authors_month from scmlog s")
	query <- new("Query", sql = q)
	data10 <- run(query)	
	
	q <- paste("select count(distinct(s.committer_id))/timestampdiff(month,min(s.date),max(s.date)) 
					as avg_committers_month from scmlog s")
	query <- new("Query", sql = q)
	data11 <- run(query)	
	
	q <- paste("select count(distinct(a.file_id))/count(distinct(s.author_id)) 
					as avg_files_author from scmlog s, actions a where a.commit_id=s.id")
	query <- new("Query", sql = q)
	data12 <- run(query)	
	
	agg_data = merge(data1, data2)
	agg_data = merge(agg_data, data3)
	agg_data = merge(agg_data, data4)
	agg_data = merge(agg_data, data5)
	agg_data = merge(agg_data, data6)
	agg_data = merge(agg_data, data7)
	agg_data = merge(agg_data, data8)
	agg_data = merge(agg_data, data9)
	agg_data = merge(agg_data, data10)
	agg_data = merge(agg_data, data11)
	agg_data = merge(agg_data, data12)	
	
	return (agg_data)
}

top_committers <- function(days = 0) {
  if (days == 0 ) {
    q <- "SELECT count(s.id) as commits, p.email as committers
          FROM scmlog s JOIN people p ON p.id=s.committer_id 
	  GROUP BY p.email ORDER BY commits DESC 
	  LIMIT 10;"
  } else {
    query <- new("Query",
                 sql = "SELECT @maxdate:=max(date) from scmlog limit 1")
    data <- run(query)
    q <- paste("SELECT count(s.id) as commits, p.email as committers
	        FROM scmlog s JOIN people p ON p.id=s.committer_id
		WHERE DATEDIFF(@maxdate,date)<",days," 
	        GROUP BY p.email ORDER BY commits DESC 
	        LIMIT 10;")
  }
  query <- new("Query", sql = q)
  data <- run(query)
  return (data)	
}

top_files_modified <- function() {
  q <- paste("select file_name, count(commit_id) as modifications 
	      from action_files a join files f on a.file_id = f.id 
	      where action_type='M' group by f.id 
	      order by modifications desc limit 10; ")	
  query <- new("Query", sql = q)
  data <- run(query)
  return (data)	
}

## TODO: Follow top_committers implementation
top_authors <- function() {
	q <- paste("select p.name as author, count(distinct(s.id)) as commits
				from people p, scmlog s
				where  s.author_id = p.id
				group by p.id
				order by count(distinct(s.id)) desc
				limit 10;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)
}

top_authors_year <- function(year) {
	q <- paste("select p.name as author, count(distinct(s.id)) as commits
				from people p,scmlog s
				where  s.author_id = p.id and year(s.date)=",year," 
				group by p.id
				order by count(distinct(s.id)) desc
				limit 10;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)
}

people <- function() {
	q <- paste ("select id,name,email from people")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data);
}

companies_name <- function() {
	q <- paste ("select c.name 
					from companies c,
					people_companies pc,
					scmlog s
					where c.id = pc.company_id and
					pc.people_id = s.author_id
					group by c.name
					order by count(distinct(s.id)) desc;")
	query <- new("Query", sql = q)
	data <- run(query)	
	return (data)
}

company_commits <- function(company_name){		
	print (company_name)
	q <- paste("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.commits, 0) as commits
					from   months m
					left join(
					select year(s.date) as year,
					month(s.date) as month,
					count(distinct(s.id)) as commits
					from   scmlog s,
					people_companies pc,
					companies c
					where  s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, "
					group by year(s.date),
					month(s.date)
					order by year(s.date),
					month(s.date)) as pm
					on (
					m.year = pm.year and
					m.month = pm.month)
					order by m.id;")
	query <- new("Query", sql = q)
	data <- run(query)	
	return (data)	
}

company_files <- function(company_name) {
	
	q <- paste ("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.files, 0) as files
					from   months m
					left join(
					select year(s.date) as year,
					month(s.date) as month,
					count(distinct(a.file_id)) as files
					from   scmlog s,
					actions a,
					people_companies pc,
					companies c
					where  a.commit_id = s.id and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, "
					group by year(s.date),
					month(s.date) 
					order by year(s.date),
					month(s.date)) as pm
					on (
					m.year = pm.year and
					m.month = pm.month)
					order by m.id;")
	query <- new("Query", sql = q)
	data <- run(query)	
	return (data)
}

company_authors <- function(company_name) {		
	q <- paste ("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.authors, 0) as authors
					from   months m
					left join(
					select year(s.date) as year,
					month(s.date) as month,
					count(distinct(s.author_id)) as authors
					from   scmlog s,
					people_companies pc,
					companies c
					where  s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, "
					group by year(s.date),
					month(s.date) 
					order by year(s.date),
					month(s.date) ) as pm
					on (
					m.year = pm.year and
					m.month = pm.month)
					order by m.id;")
	query <- new("Query", sql = q)
	data <- run(query)	
	return (data)
}

company_committers <- function(company_name) {		
	q <- paste ("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.committers, 0) as committers
					from   months m
					left join(
					select year(s.date) as year,
					month(s.date) as month,
					count(distinct(s.committer_id)) as committers
					from   scmlog s,
					people_companies pc,
					companies c
					where  s.committer_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, "
					group by year(s.date),
					month(s.date) 
					order by year(s.date),
					month(s.date) ) as pm
					on (
					m.year = pm.year and
					m.month = pm.month)
					order by m.id;")
	query <- new("Query", sql = q)
	data <- run(query)	
	return (data)
}

company_lines <- function(company_name) {
	
	q <- paste ("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.added_lines, 0) as added_lines,
					IFNULL(pm.removed_lines, 0) as removed_lines
					from   months m
					left join(
					select year(s.date) as year,
					month(s.date) as month,
					sum(cl.added) as added_lines,
					sum(cl.removed) as removed_lines
					from   commits_lines cl,
					scmlog s,
					people_companies pc,
					companies c
					where  cl.commit_id = s.id and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, "
					group by year(s.date),
					month(s.date)
					order by year(s.date),
					month(s.date)) as pm
					on (
					m.year = pm.year and
					m.month = pm.month)
					order by m.id;")
	query <- new("Query", sql = q)
	data <- run(query)	
	return (data)	
}

evol_info_data_company <- function(company_name) {
	
	# Get some general stats from the database
	##
	q <- paste("SELECT count(s.id) as commits, 
					count(distinct(s.author_id)) as authors,
					DATE_FORMAT (min(s.date), '%Y-%m-%d') as first_date,
					DATE_FORMAT (max(s.date), '%Y-%m-%d') as last_date
					FROM scmlog s,
					people_companies pc,
					companies c
					where s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data1 <- run(query)	
	q <- paste("SELECT count(distinct(file_id)) as files
					from actions a,
					scmlog s,
					people_companies pc,
					companies c
					where a.commit_id = s.id and
					s.date>=pc.init and 
					s.date<=pc.end and
					s.author_id = pc.people_id and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data3 <- run(query)	
	q <- paste("SELECT count(*) as actions 
					from actions a, 
					scmlog s,
					people_companies pc,
					companies c
					where s.id = a.commit_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					s.author_id = pc.people_id and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data5 <- run(query)	
	q <- paste("select count(s.id)/timestampdiff(month,min(s.date),max(s.date)) as avg_commits_month
					from scmlog s,
					people_companies pc,
					companies c
					where
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data7 <- run(query)	
	q <- paste("select count(distinct(a.file_id))/timestampdiff(month,min(s.date),max(s.date)) as avg_files_month
					from scmlog s, 
					actions a,
					people_companies pc,
					companies c
					where a.commit_id=s.id and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data8 <- run(query)	
	q <- paste("select count(distinct(s.id))/count(distinct(s.author_id)) as avg_commits_author
					from scmlog s, 
					identities i,
					people_companies pc,
					companies c
					where
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data9 <- run(query)	
	q <- paste("select count(distinct(s.author_id))/timestampdiff(month,min(s.date),max(s.date)) as avg_authors_month
					from scmlog s,
					people_companies pc,
					companies c
					where s.author_id is not null and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data10 <- run(query)	
	q <- paste("select count(distinct(a.file_id))/count(distinct(s.author_id)) as avg_files_author
					from scmlog s, 
					actions a,
					people_companies pc,
					companies c
					where a.commit_id=s.id and
					s.author_id is not null and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name)
	query <- new("Query", sql = q)
	data11 <- run(query)
	
	agg_data = merge(data1, data3)
	agg_data = merge(agg_data, data5)
	agg_data = merge(agg_data, data7)
	agg_data = merge(agg_data, data8)
	agg_data = merge(agg_data, data9)
	agg_data = merge(agg_data, data10)
	agg_data = merge(agg_data, data11)
	return (agg_data)
}

evol_info_data_companies <- function() {
	
	q <- paste ("select count(*) as companies from companies")
	query <- new("Query", sql = q)
	data13 <- run(query)
	
	q <- paste("select count(distinct(c.id)) as companies_2006
					from scmlog s,
					people_companies pc,
					companies c
					where s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					year(s.date) = 2006")
	query <- new("Query", sql = q)
	data14 <- run(query)
	
	q <- paste("select count(distinct(c.id)) as companies_2009
					from scmlog s,
					people_companies pc,
					companies c
					where s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					year(s.date) = 2009")
	query <- new("Query", sql = q)
	data15 <- run(query)
	
	q <- paste("select count(distinct(c.id)) as companies_2012
					from scmlog s,
					people_companies pc,
					companies c
					where s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					year(s.date) = 2012")
	query <- new("Query", sql = q)
	data16 <- run(query)
	
	
	agg_data = merge(data13, data14)
	agg_data = merge(agg_data, data15)
	agg_data = merge(agg_data, data16)
	return (agg_data)
}

company_top_authors <- function(company_name) {
	
	q <- paste ("select p.name  as author,
					count(distinct(s.id)) as commits                         
					from people p,
					scmlog s,
					people_companies pc,
					companies c
					where  p.id = s.author_id and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, "
					group by p.id
					order by count(distinct(s.id)) desc
					limit 10;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)
}

company_top_authors_year <- function(company_name, year){
	
	q <- paste ("select p.name as author,
					count(distinct(s.id)) as commits
					from people p,
					scmlog s,
					people_companies pc,
					companies c
					where  p.id = s.author_id and
					s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end and
					pc.company_id = c.id and
					c.name =", company_name, " and
					year(s.date)=",year,"
					group by p.id
					order by count(distinct(s.id)) desc
					limit 10;")	
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)	
}

evol_companies <- function(){	
	q <- paste("select m.id as id,
					m.year as year,
					m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date,
					IFNULL(pm.companies, 0) as num_companies
					from   months m
					left join(
					select year(s.date) as year,
					month(s.date) as month,
					count(distinct(pc.company_id)) as companies
					from   scmlog s,
					people_companies pc
					where  s.author_id = pc.people_id and
					s.date>=pc.init and 
					s.date<=pc.end
					group by year(s.date),
					month(s.date)
					order by year(s.date),
					month(s.date)) as pm
					on (  
					m.year = pm.year and
					m.month = pm.month)
					order by m.id;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)	
}

repos_name <- function() {
	q <- paste ("select name from repositories order by name;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)	
}

repo_commits <- function(repo_name){		
	q <- paste("SELECT m.id as id, m.year as year, m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date, 
					IFNULL(pm.commits, 0) as commits
					FROM months m
					LEFT JOIN (
					SELECT year(s.date) as year, month(s.date) as month,
					COUNT(distinct(s.id)) as commits
					FROM scmlog s, repositories r
					WHERE r.name =", repo_name, " AND r.id = s.repository_id
					GROUP BY YEAR(s.date), MONTH(s.date)
					ORDER BY YEAR(s.date),
					MONTH(s.date)) 
					AS pm
					ON (m.year = pm.year and m.month = pm.month)
					ORDER BY m.id;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)		
}

repo_files <- function(repo_name) {		
	q <- paste("SELECT m.id as id, m.year as year, m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date, 
					IFNULL(pm.files, 0) as files
					FROM months m
					LEFT JOIN (
					SELECT year(s.date) as year, month(s.date) as month,
					COUNT(distinct(a.file_id)) as files
					FROM scmlog s, actions a, repositories r
					WHERE r.name =", repo_name, " AND r.id = s.repository_id
					AND a.commit_id = s.id
					GROUP BY YEAR(s.date), MONTH(s.date)
					ORDER BY YEAR(s.date),
					MONTH(s.date)) 
					AS pm
					ON (m.year = pm.year and m.month = pm.month)
					ORDER BY m.id;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)		
}

# Unique identities not included
repo_comitters <- function(repo_name) {
	q <- paste("SELECT m.id as id, m.year as year, m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date, 
					IFNULL(pm.committers, 0) as committers
					FROM months m
					LEFT JOIN (
					SELECT year(s.date) as year, month(s.date) as month,
					COUNT(distinct(p.id)) as committers
					FROM scmlog s, people p, repositories r
					WHERE r.name =", repo_name, " AND r.id = s.repository_id
					AND p.id = s.committer_id
					GROUP BY YEAR(s.date), MONTH(s.date)
					ORDER BY YEAR(s.date),
					MONTH(s.date)) 
					AS pm
					ON (m.year = pm.year and m.month = pm.month)
					ORDER BY m.id;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)			
}

# Unique identities not included
repo_authors <- function(repo_name) {
	q <- paste("SELECT m.id as id, m.year as year, m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date, 
					IFNULL(pm.authors, 0) as authors
					FROM months m
					LEFT JOIN (
					SELECT year(s.date) as year, month(s.date) as month,
					COUNT(distinct(p.id)) as authors
					FROM scmlog s, people p, repositories r
					WHERE r.name =", repo_name, " AND r.id = s.repository_id
					AND p.id = s.author_id
					GROUP BY YEAR(s.date), MONTH(s.date)
					ORDER BY YEAR(s.date),
					MONTH(s.date)) 
					AS pm
					ON (m.year = pm.year and m.month = pm.month)
					ORDER BY m.id;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)			
}

repo_lines <- function(repo_name) {
	q <- paste("SELECT m.id as id, m.year as year, m.month as month,
					DATE_FORMAT(m.date, '%b %Y') as date, 
					IFNULL(pm.added_lines, 0) as added_lines,
					IFNULL(pm.removed_lines, 0) as removed_lines
					FROM months m
					LEFT JOIN (
					SELECT year(s.date) as year, month(s.date) as month,
					SUM(cl.added) as added_lines,
					SUM(cl.removed) as removed_lines
					FROM scmlog s, commits_lines cl, repositories r
					WHERE r.name =", repo_name, " AND r.id = s.repository_id
					AND cl.commit_id = s.id
					GROUP BY YEAR(s.date), MONTH(s.date)
					ORDER BY YEAR(s.date),
					MONTH(s.date)) 
					AS pm
					ON (m.year = pm.year and m.month = pm.month)
					ORDER BY m.id;")
	query <- new("Query", sql = q)
	data <- run(query)
	return (data)				
}

evol_info_data_repo <- function(repo_name) {
	
	# Get some general stats from the database
	##
	q <- paste("SELECT count(s.id) as commits, 
					count(distinct(s.author_id)) as authors,
					DATE_FORMAT (min(s.date), '%Y-%m-%d') as first_date,
					DATE_FORMAT (max(s.date), '%Y-%m-%d') as last_date
					FROM scmlog s, repositories r
					WHERE r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data1 <- run(query)
	
	q <- paste("SELECT count(distinct(file_id)) as files, count(*) as actions
					FROM actions a, scmlog s, repositories r
					WHERE a.commit_id = s.id AND
					r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data2 <- run(query)
	
	q <- paste("select count(s.id)/timestampdiff(month,min(s.date),max(s.date)) 
					as avg_commits_month
					FROM scmlog s, repositories r
					WHERE r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data3 <- run(query)
	
	q <- paste("select count(distinct(a.file_id))/timestampdiff(month,min(s.date),max(s.date)) 
					as avg_files_month
					FROM scmlog s, actions a, repositories r
					WHERE a.commit_id=s.id AND
					r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data4 <- run(query)
	
	q <- paste("select count(distinct(s.id))/count(distinct(s.author_id)) 
					AS avg_commits_author
					FROM scmlog s, repositories r
					WHERE r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data5 <- run(query)
		
	q <- paste("select count(distinct(s.author_id))/timestampdiff(month,min(s.date),max(s.date)) 
					AS avg_authors_month
					FROM scmlog s, repositories r
					WHERE r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data6 <- run(query)
	
	q <- paste("select count(distinct(a.file_id))/count(distinct(s.author_id)) 
					AS avg_files_author
					FROM scmlog s, actions a, repositories r
					WHERE a.commit_id=s.id AND
					r.id = s.repository_id AND
					r.name =", repo_name)
	query <- new("Query", sql = q)
	data7 <- run(query)
	
	agg_data = merge(data1, data2)
	agg_data = merge(agg_data, data3)
	agg_data = merge(agg_data, data4)
	agg_data = merge(agg_data, data5)
	agg_data = merge(agg_data, data6)
	agg_data = merge(agg_data, data7)
	return (agg_data)
}

##
## Data from MLStats database
##

get.monthly <- function () {
  ## Sent messages
  q <- paste("SELECT year(first_date) * 12 + month(first_date) AS id,
	        year(first_date) AS year,
		month(first_date) AS month,
		DATE_FORMAT (first_date, '%b %Y') as date,
		count(message_ID) AS sent
		FROM messages
		GROUP BY year,month
		ORDER BY year,month")
  query <- new ("Query", sql = q)
  sent_monthly <- run(query)
	
  ## Senders
  q <- paste ("SELECT year(first_date) * 12 + month(first_date) AS id,
		year(first_date) AS year,
		month(first_date) AS month,
		DATE_FORMAT (first_date, '%b %Y') as date,
		count(distinct(email_address)) AS senders
		FROM messages
		JOIN messages_people on (messages_people.message_id = messages.message_ID)
		WHERE type_of_recipient='From'
		GROUP BY year,month
		ORDER BY year,month")
  query <- new ("Query", sql = q)
  senders_monthly <- run(query)
  
  # repositories
  field = "mailing_list"
  q <- paste ("select distinct(mailing_list) from messages")
  query <- new ("Query", sql = q)
  mailing_lists <- run(query)
  
  if (is.na(mailing_lists$mailing_list)) {
	  field = "mailing_list_url"
  }		
  q <- paste ("SELECT year(first_date) * 12 + month(first_date) AS id,
				  year(first_date) AS year,
				  month(first_date) AS month,
				  DATE_FORMAT (first_date, '%b %Y') as date,
				  count(DISTINCT(",field,")) AS repositories
				  FROM messages
				  GROUP BY year,month
				  ORDER BY year,month")
  query <- new ("Query", sql = q)
  repos_monthly <- run(query)
  
  mls_monthly <- completeZeroMonthly (merge (sent_monthly, senders_monthly, all = TRUE))
  mls_monthly <- completeZeroMonthly (merge (mls_monthly, repos_monthly, all = TRUE))  
  mls_monthly[is.na(mls_monthly)] <- 0
  return (mls_monthly)
}

analyze.monthly.list <- function (listname) {

    field = "mailing_list"
    listname_file = gsub("/","_",listname)

    if(length(i <- grep("http",listname))) {
        field = "mailing_list_url"
        cat(listname, " is a URL\n")
    }

    ## Messages sent	
    q <- paste("SELECT year(first_date) * 12 + month(first_date) AS id,
	          year(first_date) AS year,
	          month(first_date) AS month,
		  DATE_FORMAT (first_date, '%b %Y') as date,
	          count(message_ID) AS sent
	        FROM messages WHERE ",field,"='",listname,"'
		GROUP BY year,month
		ORDER BY year,month",sep = '') 
    query <- new ("Query", sql = q)
    sent_monthly <- run(query)	
    ##print (sent_monthly)
	
    ## All subjects	
    q <- paste ("SELECT year(first_date) * 12 + month(first_date) AS id,
	           year(first_date) AS year,
	           month(first_date) AS month,
	           DATE_FORMAT (first_date, '%b %Y') as date,
	           subject
	         FROM messages  WHERE ",field,"='",listname,"'
	         ORDER BY year,month", sep = '')
    query <- new ("Query", sql = q)
    subjects_monthly <- run(query)
	
    ## Senders
    q <- paste ("SELECT year(first_date) * 12 + month(first_date) AS id,
	           year(first_date) AS year,
	           month(first_date) AS month,
	           DATE_FORMAT (first_date, '%b %Y') as date,
	           count(distinct(email_address)) AS senders
	         FROM messages
	         JOIN messages_people on (messages_people.message_id = messages.message_ID)
	         WHERE type_of_recipient='From' AND ",field,"='",listname,"'
	         GROUP BY year,month
	         ORDER BY year,month", sep = '')
    query <- new ("Query", sql = q)
    senders_monthly <- run(query)

	## TODO: this query not sure if it is correct. Not same results in VizGrimoireJS
    ## All people monthly
    q <- paste ("SELECT year(first_date) * 12 + month(first_date) AS id,
	           year(first_date) AS year,
	           month(first_date) AS month,
	           DATE_FORMAT (first_date, '%b %Y') as date,
	           email_address
	         FROM messages
	         JOIN messages_people on (messages_people.message_id = messages.message_ID)
	         WHERE type_of_recipient='From' AND ",field,"='",listname,"'
	         ORDER BY year,month", sep = '')
    query <- new ("Query", sql = q)
    emails_monthly <- run(query)		

	mls_monthly <- completeZeroMonthly (merge (sent_monthly, senders_monthly, all = TRUE))
	mls_monthly[is.na(mls_monthly)] <- 0
	# TODO: Multilist approach. We will obsolete it in future
	createJSON (mls_monthly, paste("data/json/mls-",listname_file,"-evolutionary.json",sep=''))
	# Multirepos filename
	createJSON (mls_monthly, paste("data/json/",listname_file,"-mls-evolutionary.json",sep=''))
	# createJSON (subjects_monthly, paste("data/json/mls-",listname,"-subjects-evolutionary.json",sep=''))
	createJSON (emails_monthly, paste("data/json/mls-",listname_file,"-emails-evolutionary.json",sep=''))
	
	
    ## Get some general stats from the database
    ##
    q <- paste ("SELECT count(*) as sent,
                   DATE_FORMAT (min(first_date), '%Y-%m-%d') as first_date,
                   DATE_FORMAT (max(first_date), '%Y-%m-%d') as last_date,
                   COUNT(DISTINCT(email_address)) as senders
                   FROM messages 
	           JOIN messages_people on (messages_people.message_id = messages.message_ID)
                   WHERE ",field,"='",listname,"'",sep='')
    query <- new ("Query", sql = q)
    data <- run(query)
	# TODO: Multilist approach. We will obsolete it in future
	createJSON (data, paste("data/json/mls-",listname_file,"-static.json",sep=''))
	# Multirepos filename
	createJSON (data, paste("data/json/",listname_file,"-mls-static.json",sep=''))
}

top_senders <- function(days = 0) {
  	if (days == 0 ) {
    	q <- "SELECT email_address as senders, count(m.message_id) as sent 
	  			FROM messages m
          		JOIN messages_people m_p on m_p.message_id=m.message_ID 
	  			GROUP by email_address ORDER BY sent DESC LIMIT 10;"
  	} else {
    	query <- new ("Query",
              sql = "SELECT @maxdate:=max(first_date) from messages limit 1")
    	data <- run(query)
    	q <- paste("SELECT email_address as senders, count(m.message_id) as sent 
		FROM messages m join messages_people m_p on m_p.message_id=m.message_ID
 		WHERE DATEDIFF(@maxdate,first_date)<",days," 
		GROUP by email_address ORDER BY sent DESC LIMIT 10;")		
  	}
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

mls_static_info <- function () {
	q <- paste ("SELECT count(*) as sent,
					DATE_FORMAT (min(first_date), '%Y-%m-%d') as first_date,
					DATE_FORMAT (max(first_date), '%Y-%m-%d') as last_date
					FROM messages")
	query <- new ("Query", sql = q)
	num_msg <- run(query)
	
	q <- paste ("SELECT count(*) as senders from people")
	query <- new ("Query", sql = q)
	num_ppl <- run(query)
	
	# num repositories
	field = "mailing_list"
	q <- paste ("select distinct(mailing_list) from messages")
	query <- new ("Query", sql = q)
	mailing_lists <- run(query)
	
	if (is.na(mailing_lists$mailing_list)) {
		field = "mailing_list_url"
	}
	q <- paste("SELECT COUNT(DISTINCT(",field,")) AS repositories FROM messages")
	query <- new ("Query", sql = q)
	num_repos <- run(query)
	
	q <- paste("SELECT mailing_list_url as url FROM mailing_lists")
	query <- new ("Query", sql = q)
	repo_info <- run(query)
	
	agg_data = merge(num_msg,num_ppl)
	agg_data = merge(agg_data, num_repos)
	agg_data = merge(agg_data, repo_info)
	return (agg_data)
}

## VizGrimoireJS ITS library
evol_closed <- function (closed_condition) {
	q <- paste ("SELECT YEAR(changed_on) * 12 + MONTH(changed_on) AS id,
					YEAR(changed_on) as year,
					MONTH(changed_on) as month,
					DATE_FORMAT (changed_on, '%b %Y') as date,
					count(issue_id) AS closed,
					count(distinct(changed_by)) AS closers
					FROM changes
					WHERE ",closed_condition," 
					GROUP BY year,month
					ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)	
}

# Closed tickets: time ticket was open, first closed, time-to-first-close
#q <- paste("SELECT issue_id, issue,
#        submitted_on as time_open,
#        time_closed,
#    time_closed_last,
#    TIMESTAMPDIFF (DAY, submitted_on, ch.time_closed) AS ttofix
#      FROM issues, (
#         SELECT
#           issue_id,
#           MIN(changed_on) AS time_closed,
#           MAX(changed_on) as time_closed_last
#         FROM changes
#         WHERE ",closed_condition,"
#         GROUP BY issue_id) ch
#      WHERE issues.id = ch.issue_id")
#res_issues_closed <- query(q)

evol_changed <- function () {
	# Changed and changers 
	q <- paste ("SELECT year(changed_on) * 12 + month (changed_on) AS id,
					year(changed_on) as year,
					month(changed_on) as month,
					DATE_FORMAT (changed_on, '%b %Y') as date,
					count(changed_by) AS changed,
					count(distinct(changed_by)) AS changers
					FROM changes
					GROUP BY year,month
					ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)	
}

evol_opened <- function (closed_condition) {
	q <- paste ("SELECT year(submitted_on) * 12 + month(submitted_on) AS id,
					year(submitted_on) AS year,
					month(submitted_on) AS month,
					DATE_FORMAT (submitted_on, '%b %Y') as date,
					count(submitted_by) AS opened,
					count(distinct(submitted_by)) AS openers
					FROM issues
					GROUP BY year,month
					ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

its_evol_repositories <- function() {
	q <- paste ("SELECT year(submitted_on) * 12 + month(submitted_on) AS id,
					year(submitted_on) AS year,
					month(submitted_on) AS month,
					DATE_FORMAT (submitted_on, '%b %Y') as date,
					count(DISTINCT(tracker_id)) AS repositories
					FROM issues
					GROUP BY year,month
					ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}


its_people <- function() {
	q <- paste ("select id,name,email,user_id from people")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

its_static_info <- function () {
	## Get some general stats from the database and url info
	##
	q <- paste ("SELECT count(*) as tickets,
					count(distinct(submitted_by)) as openers,
					DATE_FORMAT (min(submitted_on), '%Y-%m-%d') as first_date,
					DATE_FORMAT (max(submitted_on), '%Y-%m-%d') as last_date 
					FROM issues")
	query <- new ("Query", sql = q)
	data <- run(query)
	
	q <- paste ("SELECT count(distinct(changed_by)) as closers FROM changes WHERE ", closed_condition)
	query <- new ("Query", sql = q)
	data1 <- run(query)

	q <- paste ("SELECT count(distinct(changed_by)) as changers FROM changes")
	query <- new ("Query", sql = q)
	data2 <- run(query)

	q <- paste ("SELECT count(*) as opened FROM issues")
	query <- new ("Query", sql = q)
	data3 <- run(query)

	q <- paste ("SELECT count(distinct(issue_id)) as changed FROM changes")
	query <- new ("Query", sql = q)
	data4 <- run(query)

	q <- paste ("SELECT count(distinct(issue_id)) as closed FROM changes WHERE", closed_condition)
	query <- new ("Query", sql = q)
	data5 <- run(query)

	q <- paste ("SELECT url,name as type FROM trackers t JOIN supported_trackers s ON t.type = s.id limit 1")	
	query <- new ("Query", sql = q)
	data6 <- run(query)

	q <- paste ("SELECT count(*) as repositories FROM trackers")
	query <- new ("Query", sql = q)
	data7 <- run(query)

	agg_data = merge(data, data1)
	agg_data = merge(agg_data, data2)
	agg_data = merge(agg_data, data3)
	agg_data = merge(agg_data, data4)
	agg_data = merge(agg_data, data5)
	agg_data = merge(agg_data, data6)
	agg_data = merge(agg_data, data7)
	return(agg_data)
}

# Top
top_closers <- function(days = 0) {
	if (days == 0 ) {
		q <- paste("SELECT p.user_id as closers, count(c.id) as closed 
						FROM changes c JOIN people p ON c.changed_by = p.id 
						WHERE ", closed_condition, " 
						GROUP BY changed_by ORDER BY closed DESC LIMIT 10;")	
	} else {
		query <- new ("Query", sql ="SELECT @maxdate:=max(changed_on) from changes limit 1;")
		data <- run(query)
		q <- paste("SELECT p.user_id as closers, count(c.id) as closed 
						FROM changes c JOIN people p ON c.changed_by = p.id 
						WHERE ", closed_condition, " 
						AND c.id in (select id from changes where DATEDIFF(@maxdate,changed_on)<",days,") 
						GROUP BY changed_by ORDER BY closed DESC LIMIT 10;")		
	}
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}


its_repos_name <- function() {
	# q <- paste ("select SUBSTRING_INDEX(url,'/',-1) AS name FROM trackers")
	q <- paste ("SELECT url AS name FROM trackers")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

repo_evol_closed <- function(repo, closed_condition){
	q <- paste ("SELECT YEAR(changed_on) * 12 + MONTH(changed_on) AS id,
					YEAR(changed_on) as year,
					MONTH(changed_on) as month,
					DATE_FORMAT (changed_on, '%b %Y') as date,
					COUNT(issue_id) AS closed,
					COUNT(DISTINCT(changed_by)) AS closers ")
	q <- paste (q, "FROM changes ")
	q <- paste (q, "JOIN issues ON (changes.issue_id = issues.id) ")
	q <- paste (q, "JOIN trackers ON (issues.tracker_id = trackers.id) ")
	q <- paste (q, "WHERE ")
	q <- paste (q, closed_condition, " ")
	q <- paste (q, "AND trackers.url=",repo)
	q <- paste (q, "GROUP BY year,month ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

repo_evol_changed <- function(repo){
	q <- paste ("SELECT YEAR(changed_on) * 12 + MONTH(changed_on) AS id,
					YEAR(changed_on) as year,
					MONTH(changed_on) as month,
					DATE_FORMAT (changed_on, '%b %Y') as date,
					COUNT(changed_by) AS changed,
					COUNT(DISTINCT(changed_by)) AS changers")
	q <- paste (q, "FROM changes ")
	q <- paste (q, "JOIN issues ON (changes.issue_id = issues.id) ")
	q <- paste (q, "JOIN trackers ON (issues.tracker_id = trackers.id) ")
	q <- paste (q, "WHERE trackers.url=",repo)
	q <- paste (q, "GROUP BY year,month ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

repo_evol_opened <- function(repo){
	q <- paste ("SELECT YEAR(submitted_on) * 12 + MONTH(submitted_on) AS id,
					YEAR(submitted_on) AS year,
					MONTH(submitted_on) AS month,
					DATE_FORMAT (submitted_on, '%b %Y') as date,
					COUNT(submitted_by) AS opened,
					COUNT(DISTINCT(submitted_by)) AS openers")
	q <- paste (q, "FROM issues ")
	q <- paste (q, "JOIN trackers ON (issues.tracker_id = trackers.id) ")
	q <- paste (q, "WHERE trackers.url=",repo)
	q <- paste (q, "GROUP BY year,month ORDER BY year,month")
	query <- new ("Query", sql = q)
	data <- run(query)
	return (data)
}

its_static_info_repo <- function (repo) {
	q <- paste ("SELECT count(distinct(submitted_by)) as openers,
					count(*) as opened,
					DATE_FORMAT (min(submitted_on), '%Y-%m-%d') as first_date,
					DATE_FORMAT (max(submitted_on), '%Y-%m-%d') as last_date 
					FROM issues ")
	q <- paste (q, "JOIN trackers ON (issues.tracker_id = trackers.id) ")
	q <- paste (q, "WHERE trackers.url=",repo)
	query <- new ("Query", sql = q)
	data <- run(query)

	q <- paste ("SELECT count(distinct(changed_by)) as closers, ")
	q <- paste (q, "count(distinct(issue_id)) as closed ")
	q <- paste (q, "FROM changes ")
	q <- paste (q, "JOIN issues ON (changes.issue_id = issues.id) ")
	q <- paste (q, "JOIN trackers ON (issues.tracker_id = trackers.id) ")	
	q <- paste (q, "WHERE ", closed_condition, " ")	
	q <- paste (q, "AND trackers.url=",repo)
	query <- new ("Query", sql = q)
	data1 <- run(query)

	q <- paste ("SELECT count(distinct(changed_by)) as changers, ")
	q <- paste (q, "count(distinct(issue_id)) as changed ")
	q <- paste (q, "FROM changes ")
	q <- paste (q, "JOIN issues ON (changes.issue_id = issues.id) ")
	q <- paste (q, "JOIN trackers ON (issues.tracker_id = trackers.id) ")	
	q <- paste (q, "WHERE trackers.url=",repo)	
	query <- new ("Query", sql = q)
	data2 <- run(query)

	agg_data = merge(data, data1)
	agg_data = merge(agg_data, data2)
	return(agg_data)
}
